{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\DELL\\\\Desktop\\\\Archive\\\\src\\\\components\\\\App\\\\App.js\";\nimport React from 'react';\nimport './App.css';\nimport Nav from '../Nav/Nav';\nimport Landing from '../Landing/Landing';\nimport Footer from '../Footer/Footer';\nimport ChallengeSection from '../ChallengeSection/ChallengeSection';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst txtgen = require('txtgen');\nconst TotalTime = 60;\nconst ServiceUrl = \"https://baconipsum.com/api/?type=all-meat&paras=3&start-with-lorem=1&format=text\";\nconst DefaultState = {\n  selectedParagraph: \"My\",\n  timerStarted: false,\n  timeRemaining: TotalTime,\n  words: 0,\n  characters: 0,\n  wpm: 0,\n  testInfo: []\n};\nclass App extends React.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = DefaultState;\n    this.GenerateNewParagraph = () => {\n      let information = txtgen.paragraph();\n      information += ' ' + txtgen.paragraph();\n      information += ' ' + txtgen.paragraph();\n      information += ' ' + txtgen.paragraph();\n      information += ' ' + txtgen.paragraph();\n      information += ' ' + txtgen.paragraph();\n      const selectedParagraphArray = information.split(\"\");\n      const testInfo = selectedParagraphArray.map(selectedLetter => {\n        return {\n          testLetter: selectedLetter,\n          status: \"notAttempted\"\n        };\n      });\n      let selectedParagraph = information;\n      this.setState({\n        ...DefaultState,\n        testInfo,\n        selectedParagraph\n      });\n    };\n    this.fetchNewParagraph = () => {\n      fetch(ServiceUrl).then(response => response.text()).then(information => {\n        const selectedParagraphArray = information.split(\"\");\n        const testInfo = selectedParagraphArray.map(selectedLetter => {\n          return {\n            testLetter: selectedLetter,\n            status: \"notAttempted\"\n          };\n        });\n        let selectedParagraph = information;\n        this.setState({\n          ...DefaultState,\n          testInfo,\n          selectedParagraph\n        });\n      });\n    };\n    this.startTimer = () => {\n      this.setState({\n        timerStarted: true\n      });\n      const timer = setInterval(() => {\n        if (this.state.timeRemaining > 0) {\n          // Change the wpm\n          const timeSpent = TotalTime - this.state.timeRemaining;\n          const wpm = timeSpent > 0 ? this.state.words / timeSpent * TotalTime : 0;\n          this.setState({\n            timeRemaining: this.state.timeRemaining - 1,\n            wpm: parseInt(wpm)\n          });\n        } else {\n          clearInterval(timer);\n        }\n      }, 1000);\n    };\n    this.startAgain = () => {\n      this.GenerateNewParagraph();\n    };\n    this.handleUserInput = inputValue => {\n      if (!this.state.timerStarted) this.startTimer();\n\n      /*\n       * 1. Handle Underflow case - All the chars should be shown as not attempted-early exit\n       * 2. Handle Overflow case - Early exit\n       * 3. Handle the backspace\n       *      - Mark the [index+1] element as not attempted (irrespective of whether the index is less than zero) \n       *      - But, dont forget to check for the overflow case\n       *          (index+1 can go outbound, when the index===length-1)\n       * 4. Update the status in the testinfo\n       *      - Find out the last char in the inputValue and its index\n       *      - Check if the character at same index in testInfo (state) matches\n       *      - Yes -> \"Correct\"\n       *      - No -> \"incorrect\"\n       * 5. Irrespected of the case, characters, words and speed (wpm) should be updated\n       */\n\n      const characters = inputValue.length;\n      const words = characters ? inputValue.split(\" \").length : 0;\n      const index = characters - 1;\n      // Make a copy of testInfo\n      let testInfo = this.state.testInfo;\n      if (index < 0) {\n        testInfo = testInfo.map((individualLetterInfo, ind) => {\n          individualLetterInfo.status = \"notAttempted\";\n          return individualLetterInfo;\n        });\n        // Setting first letter as not attempted if the index<0 means no text\n        this.setState({\n          testInfo: testInfo,\n          characters,\n          words\n        });\n        return;\n      }\n      if (index >= this.state.selectedParagraph.length - 1) {\n        this.setState({\n          characters,\n          words\n        });\n        return;\n      }\n      if (!(index === this.state.selectedParagraph - 1)) {\n        // testInfo[index + 1].status = \"notAttempted\"\n        testInfo = testInfo.map((individualLetterInfo, ind) => {\n          if (ind >= index + 1) {\n            individualLetterInfo.status = \"notAttempted\";\n          } else {\n            individualLetterInfo.status = inputValue[ind] === testInfo[ind].testLetter ? \"correct\" : \"incorrect\";\n          }\n          // console.log(individualLetterInfo)\n          return individualLetterInfo;\n        });\n      }\n      // console.log(this.state)\n\n      // Check for the correct typed letter\n      const isCorrect = inputValue[index] === testInfo[index].testLetter;\n      // Update the testInfo\n      testInfo[index].status = isCorrect ? \"correct\" : \"incorrect\";\n      // Update the state\n      this.setState({\n        testInfo,\n        words,\n        characters\n      });\n    };\n  }\n  componentDidMount() {\n    this.GenerateNewParagraph();\n  }\n  render() {\n    // console.log(\"Render method called\")\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"app\",\n      children: [/*#__PURE__*/_jsxDEV(Nav, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 165,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Landing, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 167,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(ChallengeSection, {\n        onInputChange: this.handleUserInput,\n        selectedParagraph: this.state.selectedParagraph,\n        words: this.state.words,\n        characters: this.state.characters,\n        wpm: this.state.wpm,\n        timeRemaining: this.state.timeRemaining,\n        timerStarted: this.state.timerStarted,\n        testInfo: this.state.testInfo,\n        startAgain: this.startAgain\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 169,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Footer, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 181,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 163,\n      columnNumber: 13\n    }, this);\n  }\n}\nexport default App;","map":{"version":3,"names":["React","Nav","Landing","Footer","ChallengeSection","jsxDEV","_jsxDEV","txtgen","require","TotalTime","ServiceUrl","DefaultState","selectedParagraph","timerStarted","timeRemaining","words","characters","wpm","testInfo","App","Component","constructor","args","state","GenerateNewParagraph","information","paragraph","selectedParagraphArray","split","map","selectedLetter","testLetter","status","setState","fetchNewParagraph","fetch","then","response","text","startTimer","timer","setInterval","timeSpent","parseInt","clearInterval","startAgain","handleUserInput","inputValue","length","index","individualLetterInfo","ind","isCorrect","componentDidMount","render","className","children","fileName","_jsxFileName","lineNumber","columnNumber","onInputChange"],"sources":["C:/Users/DELL/Desktop/Archive/src/components/App/App.js"],"sourcesContent":["import React from 'react'\nimport './App.css'\nimport Nav from '../Nav/Nav'\nimport Landing from '../Landing/Landing'\nimport Footer from '../Footer/Footer'\nimport ChallengeSection from '../ChallengeSection/ChallengeSection'\nconst txtgen = require('txtgen');\n\nconst TotalTime = 60\nconst ServiceUrl = \"https://baconipsum.com/api/?type=all-meat&paras=3&start-with-lorem=1&format=text\"\nconst DefaultState = {\n    selectedParagraph: \"My\",\n    timerStarted: false,\n    timeRemaining: TotalTime,\n    words: 0,\n    characters: 0,\n    wpm: 0,\n    testInfo: []\n}\nclass App extends React.Component {\n    state = DefaultState\n\n    GenerateNewParagraph = () => {\n        let information = txtgen.paragraph()\n        information += ' ' + txtgen.paragraph()\n        information += ' ' + txtgen.paragraph()\n        information += ' ' + txtgen.paragraph()\n        information += ' ' + txtgen.paragraph()\n        information += ' ' + txtgen.paragraph()\n        const selectedParagraphArray = information.split(\"\");\n        const testInfo = selectedParagraphArray.map((selectedLetter) => {\n            return {\n                testLetter: selectedLetter,\n                status: \"notAttempted\"\n            }\n        })\n        let selectedParagraph = information\n        this.setState({ ...DefaultState, testInfo, selectedParagraph })\n    }\n\n    fetchNewParagraph = () => {\n        fetch(ServiceUrl).then(response => response.text()).then((information) => {\n\n            const selectedParagraphArray = information.split(\"\");\n            const testInfo = selectedParagraphArray.map((selectedLetter) => {\n                return {\n                    testLetter: selectedLetter,\n                    status: \"notAttempted\"\n                }\n            })\n            let selectedParagraph = information\n            this.setState({ ...DefaultState, testInfo, selectedParagraph })\n        })\n\n    }\n\n    componentDidMount() {\n        this.GenerateNewParagraph()\n    }\n\n    startTimer = () => {\n        this.setState({ timerStarted: true })\n        const timer = setInterval(() => {\n            if (this.state.timeRemaining > 0) {\n                // Change the wpm\n                const timeSpent = TotalTime - this.state.timeRemaining\n                const wpm = timeSpent > 0 ? ((this.state.words / timeSpent) * TotalTime) : 0\n\n                this.setState({\n                    timeRemaining: this.state.timeRemaining - 1,\n                    wpm: parseInt(wpm)\n                })\n            }\n            else {\n                clearInterval(timer)\n            }\n        }, 1000)\n    }\n\n    startAgain = () => {\n        this.GenerateNewParagraph()\n    }\n\n    handleUserInput = (inputValue) => {\n        if (!this.state.timerStarted)\n            this.startTimer()\n\n        /*\n         * 1. Handle Underflow case - All the chars should be shown as not attempted-early exit\n         * 2. Handle Overflow case - Early exit\n         * 3. Handle the backspace\n         *      - Mark the [index+1] element as not attempted (irrespective of whether the index is less than zero) \n         *      - But, dont forget to check for the overflow case\n         *          (index+1 can go outbound, when the index===length-1)\n         * 4. Update the status in the testinfo\n         *      - Find out the last char in the inputValue and its index\n         *      - Check if the character at same index in testInfo (state) matches\n         *      - Yes -> \"Correct\"\n         *      - No -> \"incorrect\"\n         * 5. Irrespected of the case, characters, words and speed (wpm) should be updated\n\n        */\n\n        const characters = inputValue.length\n        const words = characters ? inputValue.split(\" \").length : 0\n        const index = characters - 1\n        // Make a copy of testInfo\n        let testInfo = this.state.testInfo\n\n        if (index < 0) {\n            testInfo = testInfo.map((individualLetterInfo, ind) => {\n                individualLetterInfo.status = \"notAttempted\"\n\n                return individualLetterInfo\n            })\n            // Setting first letter as not attempted if the index<0 means no text\n            this.setState({\n                testInfo: testInfo,\n                characters,\n                words\n            })\n            return\n        }\n        if (index >= this.state.selectedParagraph.length - 1) {\n            this.setState({ characters, words })\n            return;\n        }\n\n\n        if (!(index === this.state.selectedParagraph - 1)) {\n            // testInfo[index + 1].status = \"notAttempted\"\n            testInfo = testInfo.map((individualLetterInfo, ind) => {\n                if (ind >= index + 1) {\n                    individualLetterInfo.status = \"notAttempted\"\n                }\n                else {\n                    individualLetterInfo.status = (inputValue[ind] === testInfo[ind].testLetter) ? \"correct\" : \"incorrect\"\n                }\n                // console.log(individualLetterInfo)\n                return individualLetterInfo\n            })\n\n\n        }\n        // console.log(this.state)\n\n        // Check for the correct typed letter\n        const isCorrect = inputValue[index] === testInfo[index].testLetter\n        // Update the testInfo\n        testInfo[index].status = isCorrect ? \"correct\" : \"incorrect\"\n        // Update the state\n        this.setState({\n            testInfo,\n            words,\n            characters\n        })\n\n    }\n\n    render() {\n        // console.log(\"Render method called\")\n        return (\n            <div className='app'>\n                {/* Nav section */}\n                <Nav />\n                {/* Landing Page */}\n                <Landing />\n                {/* Challenge Section */}\n                <ChallengeSection\n                    onInputChange={this.handleUserInput}\n                    selectedParagraph={this.state.selectedParagraph}\n                    words={this.state.words}\n                    characters={this.state.characters}\n                    wpm={this.state.wpm}\n                    timeRemaining={this.state.timeRemaining}\n                    timerStarted={this.state.timerStarted}\n                    testInfo={this.state.testInfo}\n                    startAgain={this.startAgain}\n                />\n                {/* Footer */}\n                <Footer />\n            </div>\n        )\n    }\n}\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}